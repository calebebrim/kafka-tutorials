import json
import logging
import requests
from confluent_kafka import Producer
from confluent_kafka.schema_registry import Schema, SchemaRegistryClient
from enum import Enum
from typing import Dict, Any, Optional
from datetime import datetime
from decimal import Decimal

# Logger setup
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class SerializationType(Enum):
    VALUE = "value"
    KEY = "key"


def create_kafka_producer(brokers: str) -> Producer:
    """Creates and returns a Kafka producer using confluent_kafka."""
    producer_config = {
        "bootstrap.servers": brokers
    }
    return Producer(producer_config)


def send_message(producer: Producer, message: Dict[str, Any], topic: str) -> None:
    """Sends a message to Kafka."""
    producer.produce(topic, key=None, value=json.dumps(message).encode("utf-8"))
    producer.flush()
    logger.info(f"Message sent to topic {topic}: {message}")

def get_default_value(avro_type: Any) -> Any:
    """Returns an appropriate default value based on the Avro type."""
    if avro_type == "string":
        return ""
    elif avro_type == "boolean":
        return False
    elif avro_type == "int":
        return 0
    elif avro_type == "float":
        return 0.0
    elif avro_type == "bytes":
        return b""
    elif isinstance(avro_type, dict) and avro_type.get("type") == "array":
        return []
    elif isinstance(avro_type, dict) and avro_type.get("type") == "record":
        return {}
    elif isinstance(avro_type, list):
        return []
    return None

def map_python_to_avro(value: Any) -> Any:
    """Map Python types to Avro types."""
    if isinstance(value, str):
        return "string"
    elif isinstance(value, bool):
        return "boolean"
    elif isinstance(value, int):
        return "int"
    elif isinstance(value, float):
        return "float"
    elif isinstance(value, bytes):
        return "bytes"
    elif isinstance(value, datetime):
        return {"type": "long", "logicalType": "timestamp-millis"}
    elif isinstance(value, Decimal):
        return {"type": "bytes", "logicalType": "decimal", "precision": 10, "scale": 2}
    elif isinstance(value, list):
        return {"type": "array", "items": map_python_to_avro(value[0])} if value else {"type": "array", "items": "string"}
    elif isinstance(value, dict):
        return {"type": "record", "name": "NestedRecord", "fields": [{"name": k, "type": map_python_to_avro(v)} for k, v in value.items()]}
    elif value is None:
        return ["null", "string"]  # Handle nullable fields
    else:
        return "string"  # Default fallback

def infer_avro_schema(data: Dict[str, Any], name: str = "AutoGeneratedSchema") -> str:
    """Generates an Avro schema from a Python dictionary structure with better type inference."""
    fields = [{"name": key, "type": map_python_to_avro(value), "default": get_default_value(map_python_to_avro(value))}
              for key, value in data.items()]
    
    schema = {
        "type": "record",
        "name": name,
        "fields": fields
    }
    
    return json.dumps(schema)

def update_schema_with_defaults(schema_registry: str, subject: str, old_schema: dict) -> None:
    """Updates the existing schema by adding default values to old fields."""
    
    for field in old_schema["fields"]:
        if "default" not in field:
            field["default"] = "" if field["type"] == "string" else 0  # Set default based on type

    updated_schema = json.dumps(old_schema)

    response = requests.post(f"{schema_registry}/subjects/{subject}/versions",
                             headers={"Content-Type": "application/json"},
                             data=json.dumps({"schema": updated_schema}))
    
    if response.status_code == 200:
        logger.info(f"Updated schema registered successfully for {subject}.")
    else:
        logger.error(f"Failed to update schema: {response.text}")


def get_schema_from_registry(
    topic: str,
    message: Dict[str, Any],
    schema_registry: str = "http://localhost:8081",
    schema_type: SerializationType = SerializationType.VALUE,
    subject: Optional[str] = None  # Allow custom subject
) -> Optional[str]:
    """Fetch schema from registry, and if different from the message, register a new version.
    
    If `subject` is provided, it is used directly. Otherwise, it defaults to `topic-schema_type`.
    """
    
    subject = subject or f"{topic}-{schema_type.value}"  # Use custom subject if provided
    schema_registry_client = SchemaRegistryClient({"url": schema_registry})

    # Infer schema from the message
    new_schema_str: str = infer_avro_schema(message)

    # Fetch latest schema from registry
    response = requests.get(f"{schema_registry}/subjects/{subject}/versions/latest")
    
    if response.status_code == 200:
        # Schema exists, compare with new schema
        latest_schema_str: str = response.json()["schema"]
        logger.info((latest_schema_str, new_schema_str))
        if latest_schema_str == new_schema_str:
            logger.info(f"Schema for {subject} is up to date.")
            return latest_schema_str  # No change needed

        else:
            logger.info(f"Schema for {subject} has changed. Registering a new version...")
            
            if isinstance(latest_schema_str, str):  # Ensure schema is a valid JSON object
                old_schema = json.loads(latest_schema_str)
            else:
                old_schema = latest_schema_str
                
            update_schema_with_defaults(schema_registry, subject, old_schema)
            new_schema_obj = Schema(new_schema_str, schema_type="AVRO")
            schema_id = schema_registry_client.register_schema(subject, new_schema_obj)
            logger.info(f"New schema version registered with ID: {schema_id}")
            return new_schema_str

    elif response.status_code == 404:
        # Schema does not exist, register for the first time
        logger.info(f"Schema not found for {subject}. Registering new schema...")
        schema_obj = Schema(new_schema_str, schema_type="AVRO")
        schema_id = schema_registry_client.register_schema(subject, schema_obj)
        logger.info(f"Schema registered with ID: {schema_id}")
        return new_schema_str

    else:
        # Unexpected error
        raise Exception(f"Error fetching schema: {response.text}")
